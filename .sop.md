# Standard Operating Procedures (SOP)

**Project:** UPanel - Security-First Ubuntu Server Control Panel  
**Company:** Inte.Team  
**Last Updated:** 2024-12-16  
**Version:** 1.0

---

## Purpose

This SOP provides procedures for:
1. **Feature Planning** - How to plan and document new features
2. **Debugging** - Server, agent, and application debugging
3. **Security** - Hardening procedures and verification
4. **Deployment** - Docker Compose and Caddy workflows

---

## üö® MANDATORY: Pre-Flight Checklist

**BEFORE starting ANY feature work:**

```
[ ] 1. Read this SOP
[ ] 2. Read DEVELOPMENT_GUIDELINES.md
[ ] 3. Read TESTING_GUIDELINES.md
[ ] 4. Read FEATURE_DESIGN_CHECKLIST.md
[ ] 5. Read WORKFLOW_ENFORCEMENT.md
[ ] 6. Check IMPLEMENTATION_TASKS.md for current phase
[ ] 7. Read COMPONENT_REUSE_CHECKLIST.md (before any UI work)
```

**‚õî DO NOT PROCEED without completing this checklist**

---

## Quick Reference

### Essential Documentation

| File | Purpose | When |
|------|---------|------|
| `DOCUMENTATION_STANDARDS.md` | Templates for all docs | Before writing docs |
| `FEATURE_DESIGN_CHECKLIST.md` | Compliance checklist | During planning |
| `WORKFLOW_ENFORCEMENT.md` | Mandatory workflow | Before ANY task |
| `COMPONENT_REUSE_CHECKLIST.md` | UI component inventory | Before UI planning |
| `DEVELOPMENT_GUIDELINES.md` | Coding standards | During coding |
| `TESTING_GUIDELINES.md` | Test standards | Writing tests |
| `IMPLEMENTATION_TASKS.md` | Phased task list | Track progress |

### Reference Documentation

| File | Purpose |
|------|---------|
| `/docs/01-overview.md` | Project scope and tech stack |
| `/docs/02-security-baseline.md` | Server hardening checklist |
| `/docs/07-authentication.md` | Login, 2FA, rate limits |
| `/docs/08-database-schema.md` | Full database design |
| `/docs/09-server-management.md` | Server lifecycle |
| `/docs/10-app-deployments.md` | Deployment pipeline |
| `/docs/11-agent-spec.md` | Agent API |
| `/docs/12-panel-api.md` | REST endpoints |

### Common Commands

```bash
# Development environment
docker compose up -d
docker compose exec app php artisan test
docker compose exec app ./vendor/bin/pint --dirty
docker compose exec app ./vendor/bin/phpstan analyse

# Feature-by-feature testing (ALWAYS use this, never full suite)
docker compose exec app php artisan test --filter=AuthTest
docker compose exec app php artisan test --filter=ServerTest

# Frontend
docker compose run --rm npm run dev
docker compose run --rm npm run build
```

---

## Feature Planning Procedure

### Step 0: Read Guidelines (MANDATORY)

**Time:** 15-20 minutes  
**Output:** Confirmed understanding of requirements

**MANDATORY ACTIONS:**

1. Read WORKFLOW_ENFORCEMENT.md first
2. Read all guideline files:
   ```
   /docs/DEVELOPMENT_GUIDELINES.md
   /docs/TESTING_GUIDELINES.md
   /docs/FEATURE_DESIGN_CHECKLIST.md
   /docs/DOCUMENTATION_STANDARDS.md
   ```

3. Verify you can answer:
   - [ ] What is the flash message format? (`['alert' => 'The X was Y.', 'type' => 'success']`)
   - [ ] What is the authorization pattern? (`auth()->user()->can()` with `abort(403)`)
   - [ ] What attribute goes on controllers? (`#[UsePolicy]`)
   - [ ] What validation syntax? (Array-based, NOT pipe strings)

**‚õî STOP: If you cannot answer these ‚Üí READ AGAIN**

### Step 1: Define Requirements

**Time:** 30-45 minutes  
**Output:** Feature README with compliance checklist

```bash
mkdir -p docs/features/{feature_name}
touch docs/features/{feature_name}/README.md
```

**Include in README:**
- [ ] Overview (what and why)
- [ ] User stories with acceptance criteria
- [ ] Guideline compliance checklist (copy from FEATURE_DESIGN_CHECKLIST.md)
- [ ] Technical design (tables, models, services, controllers)
- [ ] API endpoints
- [ ] Test scenarios

### Step 2: Document Database Changes

**Time:** 30 minutes per table  
**Output:** Migration docs in `/docs/database/migrations/`

```bash
# Find next migration number
ls docs/database/migrations/ | sort -n | tail -1
# Create doc
touch docs/database/migrations/{number}_{name}.md
```

Use template from DOCUMENTATION_STANDARDS.md.

### Step 3: Check Existing Components (MANDATORY)

**‚ö†Ô∏è CRITICAL: Before planning ANY UI components**

```bash
# Check what exists
ls -la inteteam_crm/resources/js/components/ui/
ls -la inteteam_crm/resources/js/components/Atoms/
ls -la inteteam_crm/resources/js/components/Molecules/
```

**Document in feature README:**
- Components to REUSE (with import paths)
- Components to CREATE (only what doesn't exist)

**Rule:** Never plan Button, Input, Label, Card, etc. - they exist in ui/

### Step 4: Write Tests First

```bash
docker compose exec app php artisan make:test {Feature}Test --pest
```

**Cover:**
- [ ] Guest access (rejected)
- [ ] Authenticated access (allowed)
- [ ] Valid data (success)
- [ ] Invalid data (validation error)
- [ ] SSH commands (mocked)

### Step 5: Implement

**Order:**
1. Migration
2. Model + Factory
3. Service (business logic)
4. Form Request (validation)
5. Policy (authorization)
6. Controller (thin, orchestration)
7. Frontend components
8. Routes

### Step 6: Quality Gate

```bash
# ALL must pass before commit
docker compose exec app php artisan test --filter={Feature}
docker compose exec app ./vendor/bin/pint --dirty
docker compose exec app ./vendor/bin/phpstan analyse
docker compose run --rm npm run build
```

---

## Granular Debugging Procedure

### Test Execution Strategy

**‚ùå NEVER:** Run full test suite at once  
**‚úÖ ALWAYS:** Test features independently

```bash
# Feature-by-feature execution
docker compose exec app php artisan test --filter=AuthTest
docker compose exec app php artisan test --filter=ServerTest
docker compose exec app php artisan test --filter=AppTest
docker compose exec app php artisan test --filter=DeploymentTest
```

**Priority Order:**
1. Authentication & Authorization
2. Server Management
3. App Deployments
4. Backups
5. Notifications

### Level 1: Reproduce the Issue

**Time:** 5-15 minutes

**Actions:**
1. What was user trying to do?
2. What did they expect?
3. What actually happened?
4. Can you reproduce consistently?

```markdown
## Reproduction Steps
1. Navigate to /servers
2. Click "Add Server"
3. Fill form and submit
4. ERROR: 500 Internal Server Error
```

### Level 2: Check Application Logs

**Time:** 10-20 minutes

```bash
# Laravel logs
tail -f storage/logs/laravel.log

# Look for:
# - Exception type
# - Error message
# - Stack trace
# - Line numbers
```

**Common Error Patterns:**
- `QueryException` ‚Üí Database issue
- `ValidationException` ‚Üí Form validation
- `AuthorizationException` ‚Üí Policy check
- `SshConnectionException` ‚Üí SSH failed

### Level 3: Isolate the Problem

**Time:** 15-30 minutes

**Identify the layer:**
- Frontend (validation, network)?
- Controller (route, auth)?
- Service (business logic)?
- SSH (connection, command)?
- Database (query, schema)?

**Add targeted logging:**
```php
// In Service
Log::info('Creating server', ['data' => $data]);
Log::info('SSH keypair generated', ['server_id' => $server->id]);
```

### Level 4: Check Database State

**Time:** 15-20 minutes

```bash
docker compose exec app php artisan tinker
```

```php
// Check record exists
$server = Server::find('01HQXYZ...');

// Check relationships
$server->apps;

// Check raw query
DB::enableQueryLog();
Server::where('status', 'online')->get();
dd(DB::getQueryLog());
```

### Level 5: Test Isolated Component

**Time:** 20-30 minutes

**Write a failing test that reproduces the bug:**

```php
test('can create server with valid data', function () {
    $user = User::factory()->admin()->twoFactorEnabled()->create();
    
    $response = $this->actingAs($user)
        ->post(route('servers.store'), [
            'name' => 'Test Server',
            'host' => '192.168.1.100',
        ]);
    
    $response->assertRedirect();
    $this->assertDatabaseHas('servers', [
        'name' => 'Test Server',
    ]);
});
```

### Level 6: Fix and Verify

**Time:** 20-60 minutes

1. Apply surgical fix (minimal change)
2. Run feature test
3. Add regression test
4. Document the fix

**Rule:** Surgical fixes over architectural changes

---

## Server Debugging Procedure

### Panel ‚Üí Agent Communication

**Check agent reachable:**
```bash
curl -X GET https://{server-ip}:8443/health
```

**Check SSH connectivity:**
```bash
ssh -i /path/to/key upanel@{server-ip} "echo 'connected'"
```

**Common issues:**
| Issue | Cause | Fix |
|-------|-------|-----|
| Connection refused | Firewall | `ufw allow 8443` |
| Auth failed | Key mismatch | Re-register server |
| Timeout | Agent not running | `docker compose up -d` |

### Agent Operations

```bash
# On managed server
cd /opt/upanel-agent
docker compose logs -f agent
docker compose ps
```

### Caddy Issues

```bash
systemctl status caddy
caddy validate --config /etc/caddy/Caddyfile
curl -vI https://{domain}
```

### Docker Compose Deployments

```bash
cd /var/www/{app}
docker compose ps
docker compose logs --tail=100
docker stats --no-stream
```

---

## Code Review Checklist

### Backend (PHP/Laravel)

#### General
- [ ] `declare(strict_types=1);` on all files
- [ ] Return type declarations on all methods
- [ ] PHPStan Level 9 passes
- [ ] Pint formatting applied

#### Controllers
- [ ] `#[UsePolicy]` attribute on class
- [ ] Authorization via `auth()->user()->can()` with `abort(403)`
- [ ] NO `$this->authorize()` method
- [ ] Flash messages: `['alert' => 'The X was Y.', 'type' => 'success']`
- [ ] Thin controllers (< 10 lines per method)
- [ ] Business logic in Services

#### Models
- [ ] `#[UsePolicy]` attribute
- [ ] `HasUlids` trait
- [ ] `casts()` method (not `$casts` property)
- [ ] `encrypted` cast for sensitive fields

#### Services
- [ ] `final` class
- [ ] Constructor injection
- [ ] Database transactions where needed
- [ ] Logging for important operations

#### Validation
- [ ] Form Request classes used
- [ ] Array-based rules (NOT pipe strings)
- [ ] `authorize()` returns `true`

#### Testing
- [ ] Feature tests cover all endpoints
- [ ] SSH commands mocked
- [ ] 80%+ coverage on new code
- [ ] Tests use factories (not seeders)

### Frontend (React/TypeScript)

- [ ] TypeScript strict mode
- [ ] Props interfaces defined
- [ ] No `any` types
- [ ] Loading states handled
- [ ] Error states handled
- [ ] Empty states handled
- [ ] Reused components documented

### Security

- [ ] No sensitive data in logs
- [ ] SSH keys encrypted in DB
- [ ] Agent tokens hashed before storage
- [ ] Rate limiting on auth endpoints
- [ ] CSRF protection on all forms

### Documentation

- [ ] Feature README complete
- [ ] Migration docs created
- [ ] API endpoints documented
- [ ] Component tree documented

---

## Critical Lessons Learned

### Lesson 1: Component-First Testing

**Issue:** Architectural rewrites during bug fixes caused cascading failures  
**Solution:** Test actual component implementation, not isolated logic

```php
// ‚úÖ CORRECT: Test the component as used
test('server creation flow works', function () {
    $user = User::factory()->admin()->twoFactorEnabled()->create();
    
    $response = $this->actingAs($user)
        ->post(route('servers.store'), ['name' => 'Test', 'host' => '1.2.3.4']);
    
    $response->assertRedirect();
});

// ‚ùå WRONG: Isolated logic test misses integration issues
```

### Lesson 2: Field Name Consistency

**Issue:** 90% of integration bugs from field name mismatches  
**Solution:** Always check `/docs/database/migrations/` before coding

```php
// ALWAYS check migration docs first
// ‚úÖ site_address_line1 (matches schema)
// ‚ùå site_address_line_1 (wrong!)
```

### Lesson 3: Surgical Fixes

**Issue:** "Improving" architecture during bug fixes caused new failures  
**Solution:** Minimal, targeted changes only

```php
// ‚úÖ CORRECT: Add one line to fix bug
$server->update(['status' => 'online']);

// ‚ùå WRONG: Refactor entire service during bug fix
```

### Lesson 4: Feature-by-Feature Testing

**Issue:** Full test suite hides specific failures  
**Solution:** Test and fix one feature at a time

```bash
# ‚úÖ CORRECT
php artisan test --filter=ServerTest
# Fix issues, re-test, move to next

# ‚ùå WRONG
php artisan test  # 147 failures, overwhelming
```

### Lesson 5: Check Components Before Planning

**Issue:** Planned duplicate UI components  
**Solution:** ALWAYS inventory existing components first

```bash
# ‚úÖ CORRECT: Check first
ls inteteam_crm/resources/js/components/ui/
# Then plan only NEW components

# ‚ùå WRONG: Plan Button.tsx when ui/button.tsx exists
```

---

## Quick Commands Reference

```bash
# Development
docker compose up -d
docker compose exec app php artisan test --filter={Feature}
docker compose exec app ./vendor/bin/pint --dirty
docker compose exec app ./vendor/bin/phpstan analyse

# Database
docker compose exec app php artisan migrate
docker compose exec app php artisan migrate:rollback --step=1
docker compose exec app php artisan tinker

# Frontend
docker compose run --rm npm run dev
docker compose run --rm npm run build

# Git
git checkout -b feature/{name}
git commit -m "feat(scope): description"
git push origin HEAD
```

---

## Summary

**ALWAYS:**
- [ ] Read guidelines before starting
- [ ] Check existing components before planning UI
- [ ] Test feature-by-feature (not full suite)
- [ ] Apply surgical fixes
- [ ] Document during development

**NEVER:**
- [ ] Skip the pre-flight checklist
- [ ] Plan components without checking existing
- [ ] Run full test suite blindly
- [ ] Make architectural changes during bug fixes
- [ ] Commit without quality gate passing
